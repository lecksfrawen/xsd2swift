/*
 XSDelement.h
 The implementation of properties and methods for the XSDelement object.
 Generated by SudzC.com
 */
#import "XSDelement.h"
#import "XSDcomplexType.h"
#import "XSDschema.h"
#import "XMLUtils.h"
#import "XSSimpleType.h"
#import "XSDenumeration.h"
#import "XSSimpleType.h"

@interface XSSimpleType (privateAccessors)
@property (strong, nonatomic) NSString *name;
@end
@interface XSDcomplexType (privateAccessors)
@property (strong, nonatomic) NSString *name;
@end

@interface XSDelement ()
@property (strong, nonatomic) id<XSType> localType;
@property (strong, nonatomic) NSString* name;
@property (strong, nonatomic) NSString* ref;
@property (strong, nonatomic) NSString* type;
@property (strong, nonatomic) NSString* substitutionGroup;
@property (strong, nonatomic) NSString* defaultValue;
@property (strong, nonatomic) NSString* fixed;
@property (strong, nonatomic) NSString* nillable;
@property (strong, nonatomic) NSString* abstractValue;
@property (strong, nonatomic) NSString* final;
@property (strong, nonatomic) NSString* block;
@property (strong, nonatomic) NSString* form;
@property (strong, nonatomic) NSNumber* minOccurs;
@property (strong, nonatomic) NSNumber* maxOccurs;
@end

@implementation XSDelement

- (id) initWithNode:(NSXMLElement*)node schema: (XSDschema*)schema minOccurs:(NSNumber *)minOccurs maxOccurs:(NSNumber *)maxOccurs {
    self = [super initWithNode:node schema:schema];
    if(self) {
        _type = [XMLUtils node: node stringAttribute: @"type"];
		_ref = [XMLUtils node: node stringAttribute: @"ref"];
        _name = [XMLUtils node: node stringAttribute: @"name"];
        if (!_name && [node.localName isEqualToString:@"any"]) {
            _name = @"Any";
            _type = @"any";
        }
        _substitutionGroup = [XMLUtils node: node stringAttribute: @"substitutionGroup"];
        _defaultValue = [XMLUtils node: node stringAttribute:  @"default"];
        _fixed = [XMLUtils node: node stringAttribute: @"fixed"];
        _nillable = [XMLUtils node: node stringAttribute: @"nillable"];
        _abstractValue = [XMLUtils node: node stringAttribute: @"abstract"];
        _final = [XMLUtils node: node stringAttribute: @"final"];
        _block = [XMLUtils node: node stringAttribute: @"block"];
        _form = [XMLUtils node: node stringAttribute: @"form"];
        
        if (_ref) {
            [self updateNameAndTypeFromRef:_ref];
        }
        
        NSNumberFormatter* numFormatter = [[NSNumberFormatter alloc] init];
        numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
        
        NSString* minOccursValue = [XMLUtils node: node stringAttribute: @"minOccurs"];
        if(minOccursValue == nil) {
            _minOccurs = minOccurs ? minOccurs : [NSNumber numberWithInt: 1];
        } else if([minOccursValue isEqual: @"unbounded"]) {
            _minOccurs = [NSNumber numberWithInt: -1];
        } else {
            _minOccurs = [numFormatter numberFromString: minOccursValue];
        }
        
        NSString* maxOccursValue = [XMLUtils node: node stringAttribute: @"maxOccurs"];
        if(maxOccursValue == nil) {
            _maxOccurs = maxOccurs ? maxOccurs : [NSNumber numberWithInt: 1];
        } else if([maxOccursValue isEqual: @"unbounded"]) {
            _maxOccurs = [NSNumber numberWithInt: -1];
        } else {
            _maxOccurs = [numFormatter numberFromString: maxOccursValue];
        }
        
        /* If we do not have a type defined yet */
        if(_type == nil) {
            /* Check if we have a complex type defined for the given element */
            NSXMLElement* complexTypeNode = [XMLUtils node:node childWithName:@"complexType"];
            if(complexTypeNode != nil) {
                _localType = [[XSDcomplexType alloc] initWithNode:complexTypeNode schema:schema];
                ((XSDcomplexType*)_localType).name = [_name stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[_name substringToIndex:1] uppercaseString]];
                NSXMLNode *n = node.parent;
                while (n != nil) {
                    if ([XMLUtils node: (NSXMLElement*)n stringAttribute: @"name"]) {
                        ((XSDcomplexType*)_localType).name = [NSString stringWithFormat:@"%@%@",[XMLUtils node: (NSXMLElement*)n stringAttribute: @"name"],((XSDcomplexType*)_localType).name];
                        break;
                    }
                    n = n.parent;
                };
                [schema addType: _localType];
            }
            else {
                NSXMLElement* simpleTypeNode = [XMLUtils node:node childWithName:@"simpleType"];
                if(simpleTypeNode != nil) {
                    _localType = [[XSSimpleType alloc] initWithNode:simpleTypeNode schema:schema];
                    ((XSSimpleType*)_localType).name = [_name stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[_name substringToIndex:1] uppercaseString]];
                    NSXMLNode *n = node.parent;
                    while (n != nil) {
                        if ([XMLUtils node: (NSXMLElement*)n stringAttribute: @"name"]) {
                            ((XSDcomplexType*)_localType).name = [NSString stringWithFormat:@"%@%@",[XMLUtils node: (NSXMLElement*)n stringAttribute: @"name"],((XSDcomplexType*)_localType).name];
                            break;
                        }
                        n = n.parent;
                    };
                    [schema addType: _localType];
                }
            }
        }

        NSAssert(_name || _ref, @"no name or ref");
        
        //specify string as default value
        if(!_ref && !_type && !_localType) {
            NSLog(@"assign default type xs:string to element %@", _name);
            _type = @"xs:string";
        }
    }
    return self;
}

- (id) initWithNode:(NSXMLElement*)node schema: (XSDschema*)schema {
    return [self initWithNode:node schema:schema minOccurs:nil maxOccurs:nil];
}

- (NSString *)name {
    if (_name) {
        return _name;
    }
    else if (self.ref) {
        [self updateNameAndTypeFromRef:self.ref];
    }
    NSAssert(_name, @"no name");
    return _name;
}

- (NSString *)type {
    if (_type) {
        return _type;
    }
    else if (self.ref) {
        [self updateNameAndTypeFromRef:self.ref];
    }
    return _type;
}

- (void)updateNameAndTypeFromRef:(NSString *)ref {
    NSArray *allTypes = [self.schema.simpleTypes arrayByAddingObjectsFromArray:self.schema.complexTypes];
    for (XSDcomplexType *innerCt in allTypes) {
        for (XSDelement *el in innerCt.globalElements) {
            if ([el.name isEqualToString:[NSXMLNode localNameForName:ref]]) {
                self.name = el.name;
                self.type = el.type ? el.type : @"xs:string";
            }
        }
    }
}

- (BOOL) hasComplexType {
//    return (self.type != nil && [[self.schema typeForName:self.type] isKindOfClass:[XSDcomplexType class]]);
    return [self.schemaType isKindOfClass:[XSDcomplexType class]];
}

- (NSString*) codeType {
    NSString* rtn;
    if([self isSingleValue]) {
        if(self.type != nil) {
            id<XSType> type =[self.schema typeForName:self.type];
            rtn = [type targetClassName];
        } else {
            rtn = [self.localType targetClassName];
        }
    } else {
        if(self.type != nil) {
            id<XSType> type = [self.schema typeForName:self.type];
            rtn = [[type arrayType] stringByAppendingFormat:@" <%@ *>", [type targetClassName]];
        } else {
            id<XSType> type = self.localType;
            rtn = [type.arrayType stringByAppendingFormat:@" <%@ *>", [type targetClassName]];
        }
    }
    
    return rtn;
}

- (id<XSType>) schemaType {
    if(self.type != nil) {
        return [self.schema typeForName: self.type];
    } else {
        return self.localType;
    }
}

- (NSString*) variableName {
    return [XSDschema variableNameFromName:self.name multiple:!self.isSingleValue];
}

/* 
 * Name:        hasEnumeration
 * Parameters:  None
 * Returns:     BOOL value that will equate to 
 *              0 - NO - False.
 *              1 - YES - True
 * Description: Will check the current element to see if the element type is associated 
 *              with an enumeration values.
 */
- (BOOL) hasEnumeration{
    BOOL isEnumeration = NO;
    
    /* Grab the type and check if it is of a simple type element */
    XSSimpleType* type = (XSSimpleType*)self.schemaType;
    if([type isKindOfClass:[XSSimpleType class]]) {
        /* ask the type */
        isEnumeration = [type hasEnumeration];
    }
    
    /* Return BOOL if we have enumerations */
    return isEnumeration;
}

- (BOOL) hasAny {
    return [self.type isEqual:@"any"];
}

- (NSString*) nameWithCapital {
    return [[self variableName] stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[self.name substringToIndex:1] uppercaseString]];
}

- (NSString*) readCodeForContent {
    NSString *rtn;
    
    /* Fetch the type and from those objects, call their appropriate method */
    if(self.localType != nil) {
        rtn = [self.localType readCodeForElement:self];
    }
    else if(self.hasEnumeration){
        XSSimpleType* simpleTypeTemp = self.schemaType;
        rtn = [simpleTypeTemp readCodeForElement:self];
    } else {
        /* Fetch the type of the current element from the schema dictionaries and read the template code and generate final code */
        rtn = [[self.schema typeForName:self.type] readCodeForElement:self];
    }
    
    return rtn;
}

- (NSString*) writeCodeForContent {
    NSString *rtn;
    
    /* Fetch the type and from those objects, call their appropriate method */
    if(self.localType != nil) {
        rtn = [self.localType writeCodeForElement:self];
    }
    else if(self.hasEnumeration){
        XSSimpleType* simpleTypeTemp = self.schemaType;
        rtn = [simpleTypeTemp writeCodeForElement:self];
    } else {
        /* Fetch the type of the current element from the schema dictionaries and read the template code and generate final code */
        rtn = [[self.schema typeForName:self.type] writeCodeForElement:self];
    }
    
    return rtn;
}

- (BOOL) isSingleValue {
    return [self.maxOccurs intValue] >= 0 && [self.maxOccurs intValue] <= 1;
}

@end
