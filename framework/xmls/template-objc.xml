<template xmlns="http://www.example.com/xsd2cocoa"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.example.com/xsd2cocoa template.xsd">
    <format_style type="builtin"/>
    <!-- known simple types-->
    <simpletype name="string" objType="NSString" arrayType="NSArray">
        <read>
            <prefix/>
            <attribute><![CDATA[
                self.{{ attribute.variableName }} = [NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding];
                {% /if %}
                ]]>
            </attribute>
            <element>
                <![CDATA[
        {% if element.isSingleValue %}self.{{ element.variableName }} = [NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding];
        {% else %}[{{ element.variableName }}Array addObject:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% /if %}]]>
            </element>
            <value><![CDATA[
                NSString *value = [NSString stringWithCString:contentValue encoding: NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = value;
                ]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[{{ attribute.variableName }}AttrValue = [self.{{ attribute.variableName }} UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[{{ element.variableName }}Value UTF8String]);]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[self.value UTF8String]);
                if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="anyURI" objType="NSURL" arrayType="NSArray">
        <read>
            <prefix/>
            <attribute>self.{{ attribute.variableName }} = [NSURL URLWithString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];
            </attribute>
            <element>
                <![CDATA[
        {% if element.isSingleValue %}self.{{ element.variableName }} = [NSURL URLWithString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[NSURL URLWithString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
        {% /if %}
        ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding: NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [NSURL URLWithString:value];
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[{{ attribute.variableName }}AttrValue = [[self."{{ attribute.variableName }}" absoluteString] UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, (mlChar*)[[self.value absoluteString] UTF8String]);]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[self.value absoluteString] UTF8String]);
                if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="boolean" objType="NSNumber" arrayType="NSArray">
        <read>
            <prefix/>
            <attribute>self.{{ attribute.variableName }} = [NSNumber numberWithBool: [[NSString stringWithCString: {{ attribute.name }}AttrValue encoding: NSUTF8StringEncoding] isEqualToString: @"true"]];
            </attribute>
            <element>
                <![CDATA[
        self.{{ element.variableName }} = [NSNumber numberWithBool:[[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding] isEqualToString:@"true"]];
        ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [NSNumber numberWithBool:[value isEqualToString:@"true"]];
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[{{ attribute.variableName }}AttrValue = [self.{{ attribute.variableName }} boolValue] ? "true" : "false";]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)([{{ element.variableName }}Value boolValue] ? "true" : "false"));]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)([{{ element.variableName }}Value boolValue] ? "true" : "false"]]);
                if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="integer" objType="NSNumber" arrayType="NSArray">
        <read>
            <prefix>
                NSNumberFormatter *numFormatter = [[NSNumberFormatter alloc] init];
                numFormatter.locale = self.locale;
                numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
            </prefix>
            <attribute>self.{{ attribute.variableName }} = [numFormatter numberFromString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];
            </attribute>
            <element>
                <![CDATA[
        self.{{ element.variableName }} = [numFormatter numberFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];
        ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [numFormatter numberFromString:value];
            </value>
        </read>
        <write>
            <prefix>
                    NSNumberFormatter *numFormatter = [[NSNumberFormatter alloc] init];
                    numFormatter.locale = self.locale;
                    numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
            </prefix>
            <attribute>
                <![CDATA[{{ attribute.variableName }}AttrValue = [[numFormatter stringFromNumber: self.{{ attribute.variableName }}] UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[numFormatter stringFromNumber:{{ element.variableName }}Value] UTF8String]);]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[numFormatter stringFromNumber:self.value] UTF8String]);
                if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="decimal" objType="NSNumber"
                arrayType="NSArray">
        <read>
            <prefix>
                NSNumberFormatter* decFormatter = [[NSNumberFormatter alloc] init];
                decFormatter.locale = self.locale;
                decFormatter.numberStyle = NSNumberFormatterDecimalStyle;
            </prefix>
            <attribute>self.{{ attribute.variableName }} = [decFormatter numberFromString: [NSString stringWithCString: {{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];
            </attribute>
            <element>
                <![CDATA[
        self.{{ element.variableName }} = [decFormatter numberFromString: [NSString stringWithCString: {{element.name}}ElementValue encoding: NSUTF8StringEncoding]];
        ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [decFormatter numberFromString:value];
            </value>
        </read>
        <write>
            <prefix>
                <![CDATA[NSNumberFormatter* integerFormatter = [[NSNumberFormatter alloc] init];
                    integerFormatter.locale = self.locale;
                integerFormatter.numberStyle = NSNumberFormatterDecimalStyle;]]>
            </prefix>
            <attribute>
                <![CDATA[{{ attribute.variableName }}AttrValue = [[integerFormatter stringFromNumber: self.{{ attribute.variableName }}] UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[integerFormatter stringFromNumber: {{ element.variableName }}Value] UTF8String]);]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[integerFormatter stringFromNumber:self.value] UTF8String]);
                if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="dateTime" objType="NSDate" arrayType="NSArray">
        <read>
            <prefix>id sRFC3339DateFormatterSubSeconds = [[NSDateFormatter alloc] init];
                [sRFC3339DateFormatterSubSeconds setLocale:self.locale];
                [sRFC3339DateFormatterSubSeconds setDateFormat:@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.SSSSSSXXXXX"];
                [sRFC3339DateFormatterSubSeconds setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
                id sRFC3339DateFormatter = [[NSDateFormatter alloc] init];
                [sRFC3339DateFormatter setLocale:self.locale];
                [sRFC3339DateFormatter setDateFormat:@"yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX"];
                [sRFC3339DateFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];</prefix>
            <attribute>self.{{ attribute.variableName }} = [sRFC3339DateFormatter
                dateFromString:[NSString stringWithCString:{{ attribute.name
                }}AttrValue encoding:NSUTF8StringEncoding]];
                if(!self.{{ attribute.variableName }}) {
                self.{{ attribute.variableName }} = [sRFC3339DateFormatterSubSeconds
                dateFromString:[NSString stringWithCString:{{ attribute.name
                }}AttrValue encoding:NSUTF8StringEncoding]];
                }</attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = [sRFC3339DateFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];
                    if(!self.{{ element.variableName }}) {
                    self.{{ element.variableName }} = [sRFC3339DateFormatterSubSeconds dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];
                    }
                    {% else %}id {{ element.variableName }}Temp = [sRFC3339DateFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];
                    if(!{{ element.variableName }}) {
                    {{ element.variableName }}Temp = [sRFC3339DateFormatterSubSeconds dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];
                    }
                    [{{ element.variableName }}Array addObject:{{ element.variableName }}Temp];
                    {% /if %}
                ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [sRFC3339DateFormatter dateFromString:value];
                if(!self.value) {
                self.value = [sRFC3339DateFormatterSubSeconds dateFromString:value];
                }</value>
        </read>
        <write>
            <prefix>
                <![CDATA[
                    id sRFC3339DateFormatter = [[NSDateFormatter alloc] init];
                    [sRFC3339DateFormatter setLocale:self.locale];
                    [sRFC3339DateFormatter setDateFormat:@"yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX"];
                    [sRFC3339DateFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];]]>
            </prefix>
            <attribute>
                <![CDATA[
                    if ( self.{{ attribute.variableName }} )
                        {{ attribute.variableName }}AttrValue = [[sRFC3339DateFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[
                    if ( {{ element.variableName }}Value )
                        xmlTextWriterWriteString(writer, (xmlChar*)[[sRFC3339DateFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);]]>
            </element>
            <value>
                <![CDATA[
                    if ( self.value ) {
                        statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[sRFC3339DateFormatter stringFromDate:self.value] UTF8String]);
                        if (statusCode < 0) return statusCode;
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="date" objType="NSDate" arrayType="NSArray">
        <read>
            <prefix>NSDateFormatter* dateOnlyFormatter = [[NSDateFormatter
                alloc] init];
                dateOnlyFormatter.dateFormat = @"yyyy-MM-dd";
                dateOnlyFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
                dateOnlyFormatter.locale = self.locale;
            </prefix>
            <attribute>self.{{ attribute.variableName }} = [dateOnlyFormatter
                dateFromString:[NSString stringWithCString:{{ attribute.name
                }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = [dateOnlyFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[dateOnlyFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
                    {% /if %}
                ]]>
            </element>
            <value>NSString *value = [NSString
                stringWithCString:contentValue
                encoding:NSUTF8StringEncoding]; value = [value
                stringByTrimmingCharactersInSet:[NSCharacterSet
                whitespaceAndNewlineCharacterSet]]; self.value =
                [dateOnlyFormatter dateFromString:value];
            </value>
        </read>
        <write>
            <prefix>
                NSDateFormatter* dateOnlyFormatter = [[NSDateFormatter alloc] init];
                dateOnlyFormatter.dateFormat = @"yyyy-MM-dd";
                dateOnlyFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
                dateOnlyFormatter.locale = self.locale;
            </prefix>
            <attribute>
                <![CDATA[
                    if ( self.{{ attribute.variableName }} )
                        {{ attribute.variableName }}AttrValue = [[dateOnlyFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];]]>
            </attribute>
            <element>
                <![CDATA[
                    if ( {{ element.variableName }}Value )
                        xmlTextWriterWriteString(writer, (xmlChar*)[[dateOnlyFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);]]>
            </element>
            <value>
                <![CDATA[
                    if ( self.value ) {
                        statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[dateOnlyFormatter stringFromDate:self.value] UTF8String]);
                        if (statusCode < 0) return statusCode;
                    }
                ]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="time" objType="NSDate" arrayType="NSArray">
        <read>
            <prefix>NSDateFormatter* timeFormatter = [[NSDateFormatter
                alloc] init];
                timeFormatter.dateFormat = @"HH:mm:ss";
                timeFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
                timeFormatter.locale = self.locale;
            </prefix>
            <attribute>self.{{ attribute.variableName }} = [timeFormatter
                dateFromString:[NSString stringWithCString:{{ attribute.name
                }}AttrValue encoding:NSUTF8StringEncoding]];
            </attribute>
            <element>
                <![CDATA[
                  {% if element.isSingleValue %}self.{{ element.variableName }} = [timeFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[timeFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
                  {% /if %}
              ]]>
            </element>
            <value>NSString *value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
                value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                self.value = [timeFormatter dateFromString:value];
            </value>
        </read>
        <write>
            <prefix>
                NSDateFormatter* timeFormatter = [[NSDateFormatter alloc] init];
                timeFormatter.dateFormat = @"HH:mm:ss";
                timeFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
            </prefix>
            <attribute>
                <![CDATA[
                    if ( self.{{ attribute.variableName }} )
                        {{ attribute.variableName }}AttrValue = [[timeFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];
                ]]>
            </attribute>
            <element>
                <![CDATA[
                    if ( {{ element.variableName }}Value )
                        xmlTextWriterWriteString(writer, (xmlChar*)[[timeFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);
                ]]>
            </element>
            <value>
                <![CDATA[
                    if ( self.value ) {
                        statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[timeFormatter stringFromDate:self.value] UTF8String]);
                        if (statusCode < 0) return statusCode;
                    }
                ]]>
            </value>
        </write>
    </simpletype>
    <!--complex type-->
    <complextype objType="NSObject-Subclass" arrayType="NSArray">
        <read>
            <element>
                <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [[{{ element.codeType }} alloc] initWithReader: reader];{% else %}[{{ element.variableName }}Array addObject: [[{{ element.schemaType.targetClassName }} alloc] initWithReader: reader]];{% /if %}]]>
            </element>
        </read>
        <write>
            <element>
                <![CDATA[int statusCode = [{{ element.variableName }}Value writeWithWriter:writer];
                    if (statusCode < 0) return statusCode;]]>
            </element>
        </write>
        <implementation>
            <!--
      Name:          Header
      Parameters:    type - the current complex type.
      Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
      this will be used to generate the class header files for the complex types.
      <Object>.h
      -->
            <header extension="h">
                <![CDATA[
        /**
        * {{  type.targetClassFileName }}.h
        {% if type.schema.hasAnnotations %} * {{ type.schema.comment }}{% /if %}
        */

        #import <Foundation/Foundation.h>
        {% if type.hasComplexBaseClass %}#import "{{ type.baseClass.targetClassFileName }}.h"{% /if %}
        {% for complexType in type.complexTypesInUse %}@class {{ complexType.targetClassName }};
        {% /for %}
        {% if type.hasAnnotations %}/**
        {{ type.comment }} */{% /if %}

        {% for enumType in type.enumTypesInUse %}#import "{{ enumType.enumerationFileName }}.h"
        {% /for %}

        {% if type.hasAnnotations %}/**
        {{ type.comment }}
        */{% /if %}
        @interface {{ type.targetClassName }} : {% if type.hasComplexBaseClass %}{{ type.baseClass.targetClassName }}{% else %}NSObject{% /if %}

        {% for attribute in type.attributes %}{% if attribute.hasAnnotations %}/**
        {{ attribute.comment }}
        */{% /if %}

        {% if attribute.hasEnumeration %}
        @property (nonatomic, assign) {{ attribute.schemaType.enumerationName }} {{ attribute.variableName }};
        {% else %}
        @property (nonatomic, strong) {{ attribute.codeType }}* {{ attribute.variableName }};
        {% /if %}

        {% /for %}
        {% for element in type.elements %}{% if element.hasAnnotations %}/**
        {{ element.comment }}
        */{% /if %}
        {% if element.hasEnumeration %}
        @property (nonatomic, assign) {{ element.schemaType.enumerationName }} {{ element.variableName }};
        {% else %}
        @property (nonatomic, {% if element.isSingleValue %}strong{% else %}copy{% /if %}) {{ element.codeType }}* {{ element.variableName }};{% /if %}{% /for %}

        {% if type.hasSimpleBaseClass %}/**
        the type's underlying value
        */
        @property (nonatomic, strong) {% if type.baseClass.hasEnumeration %}{{ type.baseClass.enumerationName }} {% else %}{{ type.baseClass.targetClassName }}* {% /if %}value;
        {% /if %}

        /** Returns a dictionary representation of this class (recursivly making dictionaries of properties) */
        @property (nonatomic, readonly) NSDictionary* dictionary;

        @end

        @interface {{ type.targetClassName }} (Reading)

        /** The class's initializer used by the reader to build the object structure during parsing (xmlTextReaderPtr at the moment) */
        - (id) initWithReader: (void*) reader;

        /** Method that is overidden by subclasses that want to extend the base type (xmlTextReaderPtr at the moment) */
        - (void) readAttributes: (void*) reader;

        /** Property that sets the NSLocale used by formatters of this type. It defaults to enUSPOSIX */
        @property(nonatomic, strong) NSLocale *locale;
        
        @end
        
        @interface {{ type.targetClassName }} (Writing)
        /* Method serialize object to xml and return status code. */
        - (int) writeWithWriter: (void*) writer;
        @end
        ]]>
            </header>
            <!--
      Name:          Class
      Parameters:    type - the current complex type.
      Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
      this will be used to generate the class files for the complex types.
      -->
            <class extension="m">
                <![CDATA[
        #import "{{ type.targetClassFileName }}.h"
        #import <libxml/xmlreader.h>
        #import <libxml/xmlwriter.h>
        {% for complexType in type.complexTypesInUse %}
        #import "{{ complexType.targetClassFileName }}.h"{% /for %}

        {% if type.hasComplexBaseClass %}
        /**
        *   Create unnamed category for {{ type.baseClass.targetClassName }} to identify methods for serialize.
        */
        @interface {{ type.baseClass.targetClassName }} ()
        
        /* Method serialize attributes of object and return status code. NOTE: Do not call this method directly. */
        - (int) writeElements: (xmlTextWriterPtr) writer;
        
        /* Method serialize attributes of object and return status code. NOTE: Do not call this method directly. */
        - (int) writeAttributes: (void*) writer;
        
        @end
        {% /if %}

        {% if type.hasComplexBaseClass %}
        @implementation {{ type.targetClassName }}
        {% else %}
        @implementation {{ type.targetClassName }} {
            NSLocale *_locale;
        }
        /**
        * the type's locale. We need this often so we put it here
        */
        - (NSLocale*)locale {
            if(!_locale) {
                _locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
            }
            return _locale;
        }
        - (void)setLocale:(NSLocale*)locale {
             _locale = locale;
        }
        {% /if %}
        
        /**
        * Name:        readAttributes
        * Parameters:  (void *) - the Libxml's xmlTextReader pointer
        * Returns:     (void)
        * Description: Read the attributes for the current XML element
        */
        - (void) readAttributes: (void*) reader {{% if type.hasComplexBaseClass %}
        [super readAttributes: reader];{% /if %}{{ type.combinedReadPrefixCode }}
        {% for attribute in type.attributes %}  char* {{ attribute.name }}AttrValue = (char*) xmlTextReaderGetAttribute(reader, (xmlChar*)"{{ attribute.name }}");
        {% if attribute.hasDefault or attribute.hasEnumeration %}
        if(!{{ attribute.name }}AttrValue) {
            {{ attribute.name }}AttrValue = (char *)xmlCharStrdup({% if attribute.hasDefault %}"{{ attribute.defaultValue }}"{% else %}"Unknown"{% /if %});
        }{% /if %}
        if({{ attribute.name }}AttrValue) {
            {{ attribute.readCodeForAttribute }}
            xmlFree({{ attribute.name }}AttrValue);
        }
        
        {% /for %}}

        /**
        * Name:        initWithReader
        * Parameters:  (void *) - the Libxml's xmlTextReader pointer
        * Returns:     returns the classes created object
        * Description: Iterate through the XML and create the {{ type.targetClassFileName }} object
        */
        - (id) initWithReader:(void *) reader {
            int _complexTypeXmlDept = xmlTextReaderDepth(reader);
            {% if type.hasComplexBaseClass %}self = [super initWithReader: reader];{% else %}self = [super init];{% /if %}
            
            /* Customize the object */
            if(self) { {{ type.combinedReadPrefixCode }}
            {% if type.hasComplexBaseClass %}{% else %}[self readAttributes: reader];{% /if %}
            {% for element in type.elements %}{% if element.isSingleValue %}{% else %}NSMutableArray *{{ element.variableName }}Array = [NSMutableArray array];{% /if %}
            {% /for %}{% if type.hasComplexBaseClass %}int _readerOk __attribute__ ((unused)) = 1;{% else %}int _readerOk __attribute__ ((unused)) = xmlTextReaderRead(reader);{% /if %}
            int _currentNodeType __attribute__ ((unused)) = xmlTextReaderNodeType(reader);
            int _currentXmlDept = xmlTextReaderDepth(reader);
            while(_readerOk && _currentNodeType != XML_READER_TYPE_NONE && _complexTypeXmlDept < _currentXmlDept) {
                BOOL handledInChild = NO;
                if(_currentNodeType == XML_READER_TYPE_ELEMENT || _currentNodeType == XML_READER_TYPE_TEXT) {
                    NSString* _currentElementName = [NSString stringWithCString: (const char*) xmlTextReaderConstLocalName(reader) encoding:NSUTF8StringEncoding];
                    {% for element in type.elements %}if([@"{{element.name}}" isEqualToString: _currentElementName]) {
                        {% if element.hasComplexType %}
                        {{ element.readCodeForContent }}
                        handledInChild = YES;
                        {% else %}
                        _readerOk = xmlTextReaderRead(reader);
                        _currentNodeType = xmlTextReaderNodeType(reader);
                        if (_currentNodeType != XML_READER_TYPE_END_ELEMENT) {
                            const char *{{element.name}}ElementValue = (const char*) xmlTextReaderConstValue(reader);
                            if({{element.name}}ElementValue) {
                                {{ element.readCodeForContent }}
                            }
                            _readerOk = xmlTextReaderRead(reader);
                            _currentNodeType = xmlTextReaderNodeType(reader);
                        }
                        {% /if %}
                    } else {% /for %}{% if type.hasSimpleBaseClass %}if([@"#text" isEqualToString: _currentElementName]){
                        const char* contentValue = (const char*) xmlTextReaderConstValue(reader);
                        if(contentValue) {
                            {{ type.readSimpleContent }}
                        }
                    } else {% /if %} {
                        NSLog(@"%s: Ignoring unexpected: %@", __PRETTY_FUNCTION__, _currentElementName);
                        break;
                    }
                }
                
                _readerOk = handledInChild ? xmlTextReaderReadState(reader) : xmlTextReaderRead(reader);
                _currentNodeType = xmlTextReaderNodeType(reader);
                _currentXmlDept = xmlTextReaderDepth(reader);
            }
            {% for element in type.elements %}
            {% if element.isSingleValue %}{% else %}if({{ element.variableName }}Array.count) self.{{ element.variableName }} = {{ element.variableName }}Array;{% /if %}{% /for %}
        }
        return self;
        }

        /**
        * Name:            dictionary
        * Parameters:
        * Returns:         Populated dictionary
        * Description:     Populate the dictionary from the simpleType names within our XSD
        */
        - (NSDictionary *)dictionary {
            /* Initial setup */
            NSMutableDictionary *dict = [NSMutableDictionary dictionary];
            {% if type.hasComplexBaseClass %}[dict setValuesForKeysWithDictionary:[super dictionary]];{% /if %}
            
            /* Populate the dictionary */
            {% for attribute in type.attributes %}
            if(self.{{ attribute.variableName }}){
                {% if attribute.hasEnumeration %}[dict setObject:{{ attribute.schemaType.enumerationName }}ToString(self.{{ attribute.variableName }}) forKey:@"{{ attribute.variableName }}"];{% else %}[dict setObject:self.{{ attribute.variableName }} forKey:@"{{ attribute.variableName }}"];{% /if %}
            }
            {% /for %}
            {% for element in type.elements %}
            {% if element.hasComplexType %}
            if(self.{{ element.variableName }}) {
                NSDictionary *{{ element.variableName }}Dict = [self.{{ element.variableName }} valueForKeyPath:@"dictionary"];
                [dict setObject:{{ element.variableName }}Dict forKey:@"{{ element.variableName }}"];
            }
            {% else %}
            if(self.{{ element.variableName }}){
                {% if element.hasEnumeration %}[dict setObject:{{ element.schemaType.enumerationName }}ToString(self.{{ element.variableName }}) forKey:@"{{ element.variableName }}"];{% else %}[dict setObject:self.{{ element.variableName }} forKey:@"{{ element.variableName }}"];{% /if %}
                
            }
            {% /if %}
            {% /for %}{% if type.hasSimpleBaseClass %}
            if(self.value){
                {% if type.baseClass.hasEnumeration %}[dict setObject:{{ type.baseClass.enumerationName }}ToString(self.value) forKey:@"value"];{% else %}[dict setObject:self.value forKey:@"value"];{% /if %}
            }{% /if %}
                
            return dict;
        }
        @end
        
        @implementation {{ type.targetClassName }} (Writing)
        
        - (int) writeAttributes: (void*) writer {
        {% if type.hasComplexBaseClass %}
        [super writeAttributes: writer];
        {% /if %}
        
        {% for simpleType in type.uniqueTemplateTypes %}
        {{ simpleType.writePrefixCode }}
        {% /for %}
        
        {% for attribute in type.attributes %}
        const char* {{ attribute.variableName }}AttrValue = NULL;
        {{ attribute.writeCodeForAttribute }}
        if ({{ attribute.variableName }}AttrValue != NULL{% if attribute.hasDefault %} && strcmp({{ attribute.variableName }}AttrValue, "{{ attribute.defaultValue }}") != 0{% /if %}) {
            int statusCode = xmlTextWriterWriteAttribute(writer, (xmlChar*)"{{ attribute.name }}", (xmlChar*){{ attribute.variableName }}AttrValue);
            if (statusCode < 0) return statusCode;
        }
        {% /for %}
        return 0;
        }
        
        - (int) writeElements: (xmlTextWriterPtr) writer {
        {% if type.hasComplexBaseClass %}
        [super writeElements: writer];
        {% /if %}
        
        {% for simpleType in type.uniqueTemplateTypes %}
        {{ simpleType.writePrefixCode }}
        {% /for %}
        
        {% for element in type.elements %}
        {% if element.isSingleValue %}
        {% if element.hasEnumeration %}
        {{ element.writeCodeForContent }}
        {% else %}
        if (self.{{ element.variableName }}) {
            xmlTextWriterStartElement(writer, (xmlChar*)"{{ element.name }}");
            id {{ element.variableName }}Value = self.{{ element.variableName }};
            {{ element.writeCodeForContent }}
            xmlTextWriterEndElement(writer);
        }
        {% /if %}
        {% else %}
        for (id {{ element.variableName }}Value in self.{{ element.variableName }}) {
            xmlTextWriterStartElement(writer, (xmlChar*)"{{ element.name }}");
            
            {{ element.writeCodeForContent }}
            
            xmlTextWriterEndElement(writer);
        }
        {% /if %}
        {% /for %}
        
        return 0;
        }
        
        - (int) writeWithWriter: (void *) writer {
        int statusCode = 0;
        
        statusCode = [self writeAttributes:writer];
        if (statusCode < 0) return statusCode;

        statusCode = [self writeElements:writer];
        if (statusCode < 0) return statusCode;
        
        {% if type.hasSimpleBaseClass %}
        if (self.value){
        {{ type.writeSimpleContent }}
        }{% /if %}
        
        return statusCode;
        }
        
        @end
            ]]>
            </class>
        </implementation>
        <reader>
            <!--
          Name:          Header Element
          Parameters:    type - the current global element type.
          Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
          this will be used to generate the header file for the elements within our XSD types.
          <Object>+File.h
          -->
            <header extension="h">
                <![CDATA[
            /**
            * {{  type.targetClassFileName }}+File.h
            {% if type.schema.hasAnnotations %} * {{ type.schema.comment }}
            {% /if %}*/
            #import <Foundation/Foundation.h>
            #import "{{ type.targetClassFileName }}.h"
            
            @interface {{ type.targetClassName }} (File)
            
            /* Reads a xml file specified by the given url and parses it, returning a {{ type.targetClassName }} */
            + ({{ type.targetClassName }}*){{ type.name }}FromURL:(NSURL*)url;
            
            /* Reads a xml file specified by the given file path and parses it, returning a {{ type.targetClassName }} */
            + ({{ type.targetClassName }}*){{ type.name }}FromFile:(NSString*)path;
            
            /* Reads xml text specified by the given data and parses it, returning a {{ type.targetClassName }} */
            + ({{ type.targetClassName }}*){{ type.name }}FromData:(NSData*)data;

            /* Method will write object to data. */
            + (NSData*)dataFrom{{ type.name }}:({{ type.targetClassName }}*){{ type.name }}Value;

            @end
            ]]>
            </header>
            <!--
          Name:           Class Element
          Parameters:     type - the current global element type.
          Description:    Work our way through the template CDATA and replace the the {{ }} with the proper values
          this will be used to generate the header file for the elements within our XSD types.
          <Object>+File.m
          -->
            <class extension="m">
                <![CDATA[
            #import "{{ type.targetClassFileName }}+File.h"
            #import <libxml/xmlreader.h>
            #import <libxml/xmlwriter.h>
            
            #define kGlobalElementNamesArray @[@"##elements##"{% for element in type.globalElements %},@"{{ element.name }}"{% /for %}]
            
            @implementation {{ type.targetClassFileName }} (File)

            /**
            * Name:            FromURL
            * Parameters:      (NSURL*) - the location of the XML file as a NSURL representation
            * Returns:         A generated {{ type.targetClassName }} object
            * Description:     Generate a {{ type.targetClassName }} object from the path
            *                  specified by the user
            */
            + ({{ type.targetClassName }}*){{ type.name }}FromURL:(NSURL*) url {
                {{ type.targetClassName }}* obj = nil;
                xmlTextReaderPtr reader = xmlReaderForFile(url.absoluteString.UTF8String,
                NULL,
                (XML_PARSE_NOBLANKS | XML_PARSE_NOCDATA | XML_PARSE_NOERROR | XML_PARSE_NOWARNING));
                int ret;
                if(reader != nil) {
                    //find the correct root
                    do {
                        ret = xmlTextReaderRead(reader);
                        if(ret == XML_READER_TYPE_ELEMENT) {
                            NSString* elementName = [NSString stringWithCString: (const char*) xmlTextReaderConstLocalName(reader) encoding:NSUTF8StringEncoding];
                            id array = kGlobalElementNamesArray;
                            NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF IN %@", array];
                            if([predicate evaluateWithObject:elementName]) {
                                obj = [[{{ type.targetClassName }} alloc] initWithReader: reader];
                                break;
                            }
                        }
                    } while(ret);
                    xmlFreeTextReader(reader);
                }
                return obj;
            }
            
            /**
            * Name:            FromFile
            * Parameters:      (NSString*) - the location of the XML file as a string
            * Returns:         A generated {{ type.targetClassName }} object
            * Description:     Generate a {{ type.targetClassName }} object from the path
            *                  specified by the user
            */
            + ({{ type.targetClassName }}*){{ type.name }}FromFile:(NSString*) path {
                return [self {{ type.name }}FromURL:[NSURL fileURLWithPath:path]];
            }
            
            /**
            * Name:            FromData:
            * Parameters:      (NSData *)
            * Returns:         A generated {{ type.targetClassName }} object
            * Description:     Generate the {{ type.targetClassName }} object from the NSData
            *                  object generated from the XML.
            */
            + ({{ type.targetClassName }}*){{ type.name }}FromData:(NSData *) data {
                /* Initial Setup */
                {{ type.targetClassName }}* obj = nil;
                /* Create the reader */
                xmlTextReaderPtr reader = xmlReaderForMemory([data bytes],
                (int)[data length],
                NULL,
                NULL,
                (XML_PARSE_NOBLANKS | XML_PARSE_NOCDATA | XML_PARSE_NOERROR | XML_PARSE_NOWARNING));
                
                /* Ensure that we have a reader and the data within it to generate the object */
                if(reader != nil) {
                    int ret = xmlTextReaderRead(reader);
                    if(ret > 0) {
                        obj = [[{{ type.targetClassName }} alloc] initWithReader: reader];
                    }
                    xmlFreeTextReader(reader);
                }
                
                return obj;
            }
            
            + (NSData*)dataFrom{{ type.name }}:({{ type.targetClassName }}*){{ type.name }}Value {
            xmlBufferPtr buf = xmlBufferCreate();
            if (buf == NULL) {
                NSLog(@"Error creating the xml buffer.");
                return nil;
            }
            
            xmlTextWriterPtr writer = xmlNewTextWriterMemory(buf, 0);
            if (writer == NULL) {
                NSLog(@"Error creating the xml writer.");
                return nil;
            }
            
            int rc = xmlTextWriterStartDocument(writer, "1.0", "utf-8", NULL);
            if (rc < 0) {
                NSLog(@"Error at xmlTextWriterStartDocument.");
                return nil;
            }
            xmlTextWriterSetIndent(writer, 1);
            xmlTextWriterSetIndentString(writer, (xmlChar *)"\t");


            // Serialize object
            xmlTextWriterStartElementNS(writer, NULL, (xmlChar *)"{{ type.name }}", (xmlChar *)"{{ type.schema.targetNamespace }}");
            int resultStatusCode = [{{ type.name }}Value writeWithWriter:writer];
            
            if (resultStatusCode < 0) {
                xmlBufferFree(buf);
                return nil;
            }
            
            xmlTextWriterEndElement(writer);
            
            rc = xmlTextWriterEndDocument(writer);
            if (rc < 0) {
                NSLog(@"Error at xmlTextWriterEndDocument.");
                return nil;
            }
            
            NSData *xmlData = [[NSData alloc] initWithBytes:(buf->content) length:(buf->use)];
            //NSLog(@"%s", (const char *) buf->content);
            
            xmlBufferFree(buf);
            
            return xmlData;
            }
            
            @end
            ]]>
            </class>
        </reader>
    </complextype>
    <enumeration objType="NS_ENUM" arrayType="">
        <read>
            <prefix/>
            <attribute>
                <![CDATA[
            self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}FromString([NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]);
            ]]>
            </attribute>
            <element>
                <![CDATA[
            self.{{ element.variableName }} = {{ element.schemaType.enumerationName }}FromString([NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]);
            ]]>
            </element>
            <value>
                <![CDATA[NSString *value = [NSString stringWithCString: contentValue encoding: NSUTF8StringEncoding];
            value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            self.value = {{ type.enumerationName }}FromString(value);
            ]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[if (self.{{ attribute.variableName }} != {{ attribute.schemaType.enumerationName }}Unknown) {
                        {{ attribute.variableName }}AttrValue = [{{ attribute.schemaType.enumerationName }}ToString(self.{{ attribute.variableName }}) UTF8String];
                    }]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteElement(writer, (xmlChar*)"{{ element.name }}", (xmlChar*)[{{ attribute.schemaType.enumerationName }}ToString(self.{{ element.variableName }}) UTF8String]);]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[{{ type.baseClass.enumerationName }}ToString(self.value) UTF8String];
            if (statusCode < 0) return statusCode;]]>
            </value>
        </write>
        <implementation>
            <header extension="h">
                <![CDATA[
            #import <Foundation/Foundation.h>
            
            typedef NS_ENUM(NSInteger, {{ type.enumerationName }}){
                {{ type.enumerationName }}Unknown = -1,
                {% for enumValue in type.enumerationValues %}{{ type.enumerationName }}{{ enumValue }},
                {% /for %}
            };
            NSString *{{ type.enumerationName }}ToString({{ type.enumerationName }} enumType);
            {{ type.enumerationName }} {{ type.enumerationName }}FromString(NSString *enumString);
            ]]>
            </header>
            <class extension="m">
                <![CDATA[
            #import "{{ type.enumerationFileName }}.h"
            
            #define k{{ type.enumerationName }}NamesArray @[@"Unknown"{% for enumValue in type.enumerationValues %},@"{{ enumValue }}"{% /for %}]
            
            NSString *{{ type.enumerationName }}ToString({{ type.enumerationName }} enumType) {
                assert(enumType < k{{ type.enumerationName }}NamesArray.count);
                return [k{{ type.enumerationName }}NamesArray objectAtIndex:enumType+1];
            }
            
            {{ type.enumerationName }} {{ type.enumerationName }}FromString(NSString *enumString) {
                NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
                NSNumberFormatter *numFormatter = [[NSNumberFormatter alloc] init];
                numFormatter.locale = locale;

                if([numFormatter numberFromString:enumString]) {
                    enumString = [@"Value" stringByAppendingString:enumString];
                }
                    
                NSUInteger enumType = [k{{ type.enumerationName }}NamesArray indexOfObject:enumString];
                assert(enumType != NSNotFound);
                return (enumType != NSNotFound) ? ({{ type.enumerationName }}) enumType-1 : {{ type.enumerationName }}Unknown;
            }
            ]]>
            </class>
        </implementation>
    </enumeration>
</template>
