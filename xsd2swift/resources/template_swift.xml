<template xmlns="http://www.example.com/xsd2cocoa"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.example.com/xsd2cocoa template.xsd">
    <format_style type="builtin"/>
    <additional_file path="libxml-bridging-header.header"
    target_path="libxml-bridging-header.h" />
    <!-- known simpletypes-->
    <simpletype name="string" objType="String" arrayType="[String]">
        <read>
            <prefix></prefix>
            <attribute>
                <![CDATA[
                    {% if attribute.hasEnumeration %}self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}.fromString(enumString: String(cString: {{ attribute.name }}AttrValue!)){% else %}self.{{ attribute.variableName }} = String(cString: {{ attribute.name }}AttrValue!){% /if %}]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = String(cString: {{element.name}}ElementValue!)
                    {% else %}{{ element.variableName }}Array.append(String(cString: {{element.name}}ElementValue!)){% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    self.value = value]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[let {{ attribute.variableName }}AttrValue = self.{{ attribute.variableName }}]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, {{ element.variableName }}Value)]]>
            </element>
            <value>
                <![CDATA[statusCode = Int(xmlTextWriterWriteString(writer, value))
                    if statusCode < 0 {
                    return statusCode
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="anyURI" objType="NSURL" arrayType="[NSURL]">
        <read>
            <prefix></prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = NSURL(string: String(cString: ({{ attribute.name }}AttrValue))!)]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = NSURL(string: String(cString: ({{element.name}}ElementValue))!)
                    {% else %}{{ element.variableName }}Array.append(NSURL(string: String(cString: ({{element.name}}ElementValue))!)!) //bad unwrapping{% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: (contentValue))
                    self.value = NSURL(string: value)]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[let {{ attribute.variableName }}AttrValue: String? = String({{ attribute.variableName }})]]>
            </attribute>
            <element>
                <![CDATA[let value = UnsafePointer<xmlChar>(String(string: {{ element.variableName }}Value.absoluteString).utf8CString)
                    xmlTextWriterWriteString(writer, value)]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, value)
                    if (statusCode < 0) {
                    return statusCode
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="boolean" objType="Bool" arrayType="[Bool]">
        <read>
            <prefix></prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = (String(cString: ({{ attribute.name }}AttrValue)) == "true")]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = String(cString: {{element.name}}ElementValue!) == "true"
                    {% else %}{{ element.variableName }}Array.append(String(cString: {{element.name}}ElementValue!) == "true"){% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    self.value = (value == "true")]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[let {{ attribute.variableName }}AttrValue: String? = self.{{ attribute.variableName }}! ? "true" : "false"]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, ({{ element.variableName }}Value ? "true" : "false"))]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, ({{ element.variableName }}Value ? "true" : "false"]]);
                    if (statusCode < 0) {
                    return statusCode
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="integer" objType="Int" arrayType="[Int]">
        <read>
            <prefix>
                <![CDATA[
                    let numFormatter = NumberFormatter()
                    numFormatter.numberStyle = .decimal
                    numFormatter.locale = self.locale
                ]]>
            </prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = numFormatter.number(from: String(cString: {{ attribute.name }}AttrValue!))!.intValue]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}
                        self.{{ element.variableName }} = numFormatter.number(from: String(cString: {{element.name}}ElementValue!))!.intValue
                    {% else %}
                        {{ element.variableName }}Array.append(numFormatter.number(from: String(cString: {{element.name}}ElementValue!))!.intValue)  //bad force unwrapping
                    {% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = numFormatter.number(from: trimmed).intValue
                    }]]>
            </value>
        </read>
        <write>
            <prefix>
                let numFormatter = NumberFormatter()
                numFormatter.numberStyle = .decimal
            </prefix>
            <attribute>
                <![CDATA[let {{ attribute.variableName }}AttrValue = numFormatter.string(from: self.{{ attribute.variableName }} as NSNumber!)]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, numFormatter.string(from: {{ element.variableName }}Value as NSNumber))]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, numFormatter.string(from: self.value as NSNumber))
                    if (statusCode < 0) {
                        return statusCode
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="decimal" objType="Double" arrayType="[Double]">
        <read>
            <prefix>
                <![CDATA[
                    let decFormatter = NumberFormatter()
                    decFormatter.numberStyle = .decimal
                    decFormatter.locale = self.locale]]>
            </prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = decFormatter.number(from: String(cString: {{ attribute.name }}AttrValue!)!)!.doubleValue]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = decFormatter.number(from: String(cString: {{element.name}}ElementValue!)!)!.doubleValue
                    {% else %}{{ element.variableName }}Array.append(decFormatter.number(from: String(cString: {{element.name}}ElementValue!)!)!.doubleValue) //bad force unwrapping{% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = decFormatter.number(from: trimmed)!.doubleValue
                    }]]>
            </value>
        </read>
        <write>
            <prefix>
                <![CDATA[let integerFormatter = NumberFormatter()
                    integerFormatter.numberStyle = .decimal]]>
            </prefix>
            <attribute>
                <![CDATA[let {{ attribute.variableName }}AttrValue = integerFormatter.string(from: self.{{ attribute.variableName }}!)]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteString(writer, integerFormatter.string(from: {{ element.variableName }}Value))]]>
            </element>
            <value>
                <![CDATA[statusCode = xmlTextWriterWriteString(writer, integerFormatter.string(from: self.value))
                    if (statusCode < 0) {
                    return statusCode
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="dateTime" objType="NSDate"
        arrayType="[NSDate]">
        <read>
            <prefix>
                <![CDATA[
                    let sRFC3339DateFormatterSubSeconds = NSDateFormatter()
                    sRFC3339DateFormatterSubSeconds.locale = self.locale
                    sRFC3339DateFormatterSubSeconds.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.SSSSSSXXXXX"
                    sRFC3339DateFormatterSubSeconds.timeZone = NSTimeZone(forSecondsFromGMT: 0)
                    
                    let sRFC3339DateFormatter = NSDateFormatter()
                    sRFC3339DateFormatter.locale = self.locale
                    sRFC3339DateFormatter.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX"
                    sRFC3339DateFormatterSubSeconds.timeZone = NSTimeZone(forSecondsFromGMT: 0)]]></prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = sRFC3339DateFormatter.dateFromString( String(cString: {{ attribute.name }}AttrValue!)! )
                    if(self.{{ attribute.variableName }} == nil) {
                    self.{{ attribute.variableName }} = sRFC3339DateFormatterSubSeconds.dateFromString( String(cString: {{ attribute.name }}AttrValue!)!)
                    }]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = sRFC3339DateFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    if(self.{{ element.variableName }} == nil) {
                    self.{{ element.variableName }} = sRFC3339DateFormatterSubSeconds.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    }
                    {% else %}var {{ element.variableName }}Temp = sRFC3339DateFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    if({{element.variableName }}Temp == nil) {
                    {{ element.variableName }}Temp = sRFC3339DateFormatterSubSeconds.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    }
                    {{ element.variableName }}Array.append(!) //bad force unwrapping{% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = sRFC3339DateFormatter.dateFromString(trimmed)
                    if(!self.value) {
                    self.value = sRFC3339DateFormatterSubSeconds.dateFromString(trimmed)
                    }
                    }]]>
            </value>
        </read>
        <write>
            <prefix>
                <![CDATA[
                    let sRFC3339DateFormatter = NSDateFormatter()
                    sRFC3339DateFormatter.locale = self.locale
                    sRFC3339DateFormatter.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX"
                    sRFC3339DateFormatter.timeZone = NSTimeZone(forSecondsFromGMT: 0)]]>
            </prefix>
            <attribute>
                <![CDATA[
                    if self.{{ attribute.variableName }} {
                    {{ attribute.variableName }}AttrValue = sRFC3339DateFormatter.stringFromDate(self.{{ attribute.variableName }})
                    }]]>
            </attribute>
            <element>
                <![CDATA[
                    if {{ element.variableName }}Value {
                    xmlTextWriterWriteString(writer, sRFC3339DateFormatter.stringFromDate({{ element.variableName }}Value))
                    }]]>
            </element>
            <value>
                <![CDATA[
                    if let value = self.value {
                    statusCode = xmlTextWriterWriteString(writer, sRFC3339DateFormatter.stringFromDate(value))
                    if statusCode < 0 {
                    return statusCode
                    }
                    }]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="date" objType="NSDate"
        arrayType="[NSDate]">
        <read>
            <prefix>
                <![CDATA[let dateOnlyFormatter = NSDateFormatter()
                    dateOnlyFormatter.dateFormat = "yyyy-MM-dd"
                    dateOnlyFormatter.timeZone = NSTimeZone(name:"UTC")
                    dateOnlyFormatter.locale = self.locale
                ]]>
            </prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = dateOnlyFormatter.dateFromString( String(cString: {{ attribute.name }}AttrValue!)!)]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = dateOnlyFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    {% else %}{{ element.variableName }}Array.append(dateOnlyFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)!) //bad force unwrapping{% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = dateOnlyFormatter.dateFromString(trimmed)
                    }]]>
            </value>
        </read>
        <write>
            <prefix>
                NSDateFormatter* dateOnlyFormatter = [[NSDateFormatter alloc] init];
                dateOnlyFormatter.dateFormat = @"yyyy-MM-dd";
                dateOnlyFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
                dateOnlyFormatter.locale = self.locale;
            </prefix>
            <attribute>
                <![CDATA[
                    if let {{ attribute.variableName }} = self.{{ attribute.variableName }} {
                    {{ attribute.variableName }}AttrValue = dateOnlyFormatter.stringFromDate:{{ attribute.variableName }}
                    }]]>
            </attribute>
            <element>
                <![CDATA[
                    if {{ element.variableName }}Value != nil {
                    xmlTextWriterWriteString(writer, dateOnlyFormatter.stringFromDate:{{ element.variableName }}Value)
                    }]]>
            </element>
            <value>
                <![CDATA[
                    if let value = self.value {
                    statusCode = xmlTextWriterWriteString(writer, dateOnlyFormatter.stringFromDate:value)
                    if (statusCode < 0) {
                    return statusCode
                    }
                    }
                ]]>
            </value>
        </write>
    </simpletype>
    <simpletype name="time" objType="NSDate"
        arrayType="[NSDate]">
        <read>
            <prefix>
                <![CDATA[let timeOnlyFormatter = NSDateFormatter()
                    timeOnlyFormatter.dateFormat = "HH:mm:ss"
                    timeOnlyFormatter.timeZone = NSTimeZone(name:"UTC")
                    timeOnlyFormatter.locale = self.locale
                ]]>
            </prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = timeOnlyFormatter.dateFromString( String(cString: {{ attribute.name }}AttrValue!)!)]]>
            </attribute>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = timeOnlyFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)
                    {% else %}{{ element.variableName }}Array.append(timeOnlyFormatter.dateFromString(String(cString: {{element.name}}ElementValue!)!)!) //bad force unwrapping{% /if %}]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = timeOnlyFormatter.dateFromString(trimmed)
                    }]]>
            </value>
        </read>
        <write>
            <prefix>
                let timeFormatter = NSDateFormatter()
                timeFormatter.dateFormat = "HH:mm:ss"
                timeFormatter.timeZone = NSTimeZone(abbreviation:"UTC")
            </prefix>
            <attribute>
                <![CDATA[
                    if let {{ attribute.variableName }} = self.{{ attribute.variableName }} {
                    {{ attribute.variableName }}AttrValue = timeFormatter.stringFromDate({{ attribute.variableName }})
                    }
                ]]>
            </attribute>
            <element>
                <![CDATA[
                    if {{ element.variableName }}Value != nil {
                    xmlTextWriterWriteString(writer, timeFormatter.stringFromDate({{ element.variableName }}Value))
                    }
                ]]>
            </element>
            <value>
                <![CDATA[
                    if let value = self.value {
                    statusCode = xmlTextWriterWriteString(writer, timeFormatter.stringFromDate(value))
                    if (statusCode < 0) {
                    return statusCode
                    }
                    }
                ]]>
            </value>
        </write>
    </simpletype>
    <!--complex type-->
    <complextype objType="@objc-Subclass"
        arrayType="[{{ type.targetClassName }}]">
        <read>
            <element>
                <![CDATA[
                    {% if element.isSingleValue %}self.{{ element.variableName }} = {{ element.codeType }}(reader: reader){% else %}{{ element.variableName }}Array.append({{ element.schemaType.targetClassName }}(reader: reader)){% /if %}]]>
            </element>
        </read>
        <write>
            <element>
                <![CDATA[let statusCode : Int = {{ element.variableName }}Value.writeWithWriter(writer: writer)
                    if statusCode < 0 {
                    return statusCode
                    }]]>
            </element>
        </write>
        <implementation>
            <header extension=""></header>
            <class extension="swift">
                <![CDATA[
                    import Foundation
                    import libxml2

                    @objc
                    class {{ type.targetClassName }} {% if type.hasComplexBaseClass %}: {{ type.baseClass.targetClassName }} {% else %}: NSObject{% /if %}{
                    {% if type.hasComplexBaseClass %}
                    {% else %}
                    /** Property that sets the Locale used by formatters of this type. It defaults to en_US_POSIX */
                    var locale = Locale(identifier: "en_US_POSIX")
                    {% /if %}
                    {% for attribute in type.attributes %}
                    var `{{ attribute.variableName }}`: {% if attribute.hasEnumeration %}{{ attribute.schemaType.enumerationName }}{% else %}{{ attribute.codeType }}{% /if %}?
                    {% /for %}
                    {% for element in type.elements %}
                    var `{{ element.variableName }}`: {% if element.hasEnumeration %}{{ element.schemaType.enumerationName }}{% else %}{{ element.codeType }}{% /if %}?
                    {% /for %}
                    {% if type.hasSimpleBaseClass %}/**
                    the type's underlying value
                    */
                    var value: {% if type.baseClass.hasEnumeration %}{{ type.baseClass.enumerationName }}{% else %}{{ type.baseClass.targetClassName }}{% /if %}?{% /if %}
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}func readAttributes(reader: xmlTextReaderPtr) {{% if type.hasComplexBaseClass %}
                    super.readAttributes(reader: reader)
                    {% /if %}{{ type.combinedReadPrefixCode }}
                    
                    {% for attribute in type.attributes %}
                    let {{ attribute.name }}AttrName = UnsafePointer<xmlChar>("{{ attribute.name }}")
                    let {{ attribute.name }}AttrValue = xmlTextReaderGetAttribute(reader, {{ attribute.name }}AttrName)
                    if({{ attribute.name }}AttrValue != nil) {
                    {{ attribute.readCodeForAttribute }}
                    xmlFree({{ attribute.name }}AttrValue)
                    }{% /for %}
                    }
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}init(reader: xmlTextReaderPtr) {
                    let _complexTypeXmlDept = xmlTextReaderDepth(reader)
                    {% if type.hasComplexBaseClass %}super.init(reader: reader){% else %}super.init(){% /if %}
                    {{ type.combinedReadPrefixCode }}{% if type.hasComplexBaseClass %}{% else %}
                    self.readAttributes(reader: reader){% /if %}
                    {% for element in type.elements %}
                    {% if element.isSingleValue %}{% else %}var {{ element.variableName }}Array = {{ element.codeType }}(){% /if %}{% /for %}
                    
                    {% if type.hasComplexBaseClass %}var _readerOk:Int32=1{% else %}var _readerOk = xmlTextReaderRead(reader){% /if %}
                    var _currentNodeType = xmlTextReaderNodeType(reader)
                    var _currentXmlDept = xmlTextReaderDepth(reader)
                    
                    while(_readerOk > 0 && _currentNodeType != 0/*XML_READER_TYPE_NONE*/ && _complexTypeXmlDept < _currentXmlDept) {
                    {% if type.hasComplexChildren %}var handledInChild = false{% /if %}
                    if(_currentNodeType == 1/*XML_READER_TYPE_ELEMENT*/ || _currentNodeType == 3/*XML_READER_TYPE_TEXT*/) {
                    let _currentElementNameXmlChar = xmlTextReaderConstLocalName(reader)
                    let _currentElementName = String(cString: _currentElementNameXmlChar!)
                    {% for element in type.elements %}if("{{element.name}}" == _currentElementName) {
                    
                    {% if element.hasComplexType %}
                    {{ element.readCodeForContent }}
                    handledInChild = true
                    {% else %}
                    _readerOk = xmlTextReaderRead(reader)
                    _currentNodeType = xmlTextReaderNodeType(reader)
                    let {{element.name}}ElementValue = xmlTextReaderConstValue(reader)
                    if {{element.name}}ElementValue != nil {
                    {{ element.readCodeForContent }}
                    }
                    _readerOk = xmlTextReaderRead(reader)
                    _currentNodeType = xmlTextReaderNodeType(reader)
                    {% /if %}
                    
                    } else {% /for %} {% if type.hasSimpleBaseClass %} if("#text" == _currentElementName){
                    let contentValue = xmlTextReaderConstValue(reader)
                    if(contentValue != nil) {
                    {{ type.readSimpleContent }}
                    }
                    } else {% /if %} if(true) {
                    print("Ignoring unexpected: \(_currentElementName)")
                    break
                    }
                    }
                    {% if type.hasComplexChildren %}_readerOk = handledInChild ? xmlTextReaderReadState(reader) : xmlTextReaderRead(reader){% else %}_readerOk = xmlTextReaderRead(reader){% /if %}
                    _currentNodeType = xmlTextReaderNodeType(reader)
                    _currentXmlDept = xmlTextReaderDepth(reader)
                    }
                    {% for element in type.elements %}
                    {% if element.isSingleValue %}{% else %}if({{ element.variableName }}Array.count > 0) { self.{{ element.variableName }} = {{ element.variableName }}Array }{% /if %}{% /for %}
                    }
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}var dictionary: [String: Any] {
                        var dict = [String: Any]()
                        {% if type.hasComplexBaseClass %}
                            for (name, value) in super.dictionary {
                                dict[name] = value
                            }
                        {% /if %}
                    
                        {% for attribute in type.attributes %}
                            if(self.{{ attribute.variableName }} != nil) {
                                {% if attribute.hasEnumeration %}
                                    let obj = {{ attribute.schemaType.enumerationName }}.toString(enumType: self.{{ attribute.variableName }}!)
                                    dict["{{ attribute.variableName }}"] = obj
                                {% else %}
                                    dict["{{ attribute.variableName }}"] = self.{{ attribute.variableName }}!
                                {% /if %}
                            }
                        {% /for %}

                        {% for element in type.elements %}
                            {% if element.hasComplexType %}
                                if(self.{{ element.variableName }} != nil) {
                                    dict["{{ element.variableName }}"] = self.{{ element.variableName }}!{% if element.isSingleValue %}{% else %}.map({$0.dictionary}){% /if %}
                                }
                            {% else %}
                                if(self.{{ element.variableName }} != nil) {
                                    {% if element.hasEnumeration %}
                                        let obj = {{ element.schemaType.enumerationName }}.toString(enumType: {{ element.variableName }}!)
                                        dict["value"] = obj
                                    {% else %}
                                        dict["{{ element.variableName }}"] = self.{{ element.variableName }}!
                                    {% /if %}
                                }
                            {% /if %}
                        {% /for %}

                        {% if type.hasSimpleBaseClass %}
                            if(self.value != nil) {
                                {% if type.baseClass.hasEnumeration %}
                                    let obj = {{ type.baseClass.enumerationName }}.toString(enumType: self.value!)
                                    dict["value"] = obj
                                {% else %}
                                    dict["value"] = self.value!
                                {% /if %}
                            }
                        {% /if %}

                        return dict
                    }
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}func writeAttributes(writer: OpaquePointer) -> Int {
                    {% if type.hasComplexBaseClass %}
                    super.writeAttributeswriter: writer)
                    {% /if %}
                    
                    {% for simpleType in type.simpleTypesInUse %}
                    {{ simpleType.writePrefixCode }}
                    {% /for %}
                    
                    {% for attribute in type.attributes %}
                    {{ attribute.writeCodeForAttribute }}
                    if {% if attribute.hasDefault %}strcmp({{ attribute.variableName }}AttrValue!, "{{ attribute.defaultValue }}") != 0{% else %}!({{ attribute.variableName }}AttrValue ?? "").isEmpty{% /if %} {
                    let statusCode = Int(xmlTextWriterWriteAttribute(writer, "{{ attribute.name }}", {{ attribute.variableName }}AttrValue!))
                    if statusCode < 0 {
                    return statusCode
                    }
                    }
                    {% /for %}
                    return 0
                    }
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}func writeElements(writer: xmlTextWriterPtr) -> Int {
                    {% if type.hasComplexBaseClass %}
                    super.writeElements(writer: writer)
                    {% /if %}
                    
                    {% for simpleType in type.simpleTypesInUse %}
                    {{ simpleType.writePrefixCode }}
                    {% /for %}
                    
                    {% for element in type.elements %}
                    {% if element.isSingleValue %}
                    {% if element.hasEnumeration %}
                    {{ element.writeCodeForContent }}
                    {% else %}
                    if let {{ element.variableName }}Value = self.{{ element.variableName }} {
                    xmlTextWriterStartElement(writer, "{{ element.name }}")
                    {{ element.writeCodeForContent }}
                    xmlTextWriterEndElement(writer)
                    }
                    {% /if %}
                    {% else %}
                    if let binding{{ element.variableName }} = self.{{ element.variableName }} {
                    for {{ element.variableName }}Value in binding{{ element.variableName }} {
                    xmlTextWriterStartElement(writer, "{{ element.name }}")
                    
                    {{ element.writeCodeForContent }}
                    
                    xmlTextWriterEndElement(writer)
                    }
                    }
                    {% /if %}
                    {% /for %}
                    
                    return 0
                    }
                    
                    {% if type.hasComplexBaseClass %}override {% /if %}func writeWithWriter(writer: OpaquePointer) -> Int {
                    var statusCode = 0
                    
                    statusCode = self.writeAttributes(writer: writer)
                    if statusCode < 0 {
                    return statusCode
                    }
                    
                    statusCode = self.writeElements(writer: writer)
                    if statusCode < 0 {
                    return statusCode
                    }
                    
                    {% if type.hasSimpleBaseClass %}
                    if let value = self.value {
                    {{ type.writeSimpleContent }}
                    }{% /if %}
                    
                    return statusCode
                    }
                    }
                ]]>
            </class>
        </implementation>
        <reader>
            <header extension=""></header>
            <class extension="swift">
                <![CDATA[
                    import Foundation
                    import libxml2

                    let kGlobalElementNamesArray = ["##elements##"{% for element in type.globalElements %},"{{ element.name }}"{% /for %}]
                    
                    extension {{ type.targetClassFileName }} {
                    
                    /**
                    * Name:            {{ type.name }}FromURL
                    * Parameters:      NSURL - the location of the XML file as a NSURL representation
                    * Returns:         A generated {{ type.targetClassName }} object
                    * Description:     Generate a {{ type.targetClassName }} object from the path
                    *                  specified by the user
                    */
                    class func {{ type.name }}FromURL(url: NSURL) -> {{ type.targetClassName }}? {
                    let s = (url.absoluteString as String!).cString(using: .utf8)
                    let reader = xmlReaderForFile( s, nil, 0/*options*/)
                    var ret: Int32
                    var obj: {{ type.targetClassName }}? = nil
                    
                    if(reader != nil) {
                    //find the correct root
                    repeat {
                    ret = xmlTextReaderRead(reader)
                    if(ret == 1/*XML_READER_TYPE_ELEMENT*/) {
                    let elementNameXmlChar = xmlTextReaderConstLocalName(reader)
                    let elementName = String(cString: elementNameXmlChar!)
                    let array = [kGlobalElementNamesArray]
                    let predicate = NSPredicate(format: "SELF IN %@", argumentArray: array)
                    if(predicate.evaluate(with: elementName)) {
                    obj = {{ type.targetClassName }}(reader: reader!)
                    break
                    }
                    }
                    } while(ret != 0)
                    xmlFreeTextReader(reader)
                    }
                    
                    return obj
                    }
                    
                    /**
                    * Name:            {{ type.name }}FromFile
                    * Parameters:      String - the location of the XML file as a string
                    * Returns:         A generated {{ type.targetClassName }} object
                    * Description:     Generate a {{ type.targetClassName }} object from the path
                    *                  specified by the user
                    */
                    class func {{ type.name }}FromFile(path:String) -> {{ type.targetClassName }}? {
                    let url = NSURL(fileURLWithPath:path)
                    return self.{{ type.name }}FromURL(url: url)
                    }
                    
                    /**
                    * Name:            {{ type.name }}FromData
                    * Parameters:      NSData
                    * Returns:         A generated {{ type.targetClassName }} object
                    * Description:     Generate the {{ type.targetClassName }} object from the NSData
                    *                  object generated from the XML.
                    */
                    class func {{ type.name }}FromData(data:NSData) -> {{ type.targetClassName }}? {
                    let bytes = data.bytes.bindMemory(to: Int8.self, capacity: data.length);
                    let length = Int32(data.length)
                    let reader = xmlReaderForMemory(bytes, length, nil, nil, 0/*options*/)
                    
                    if(reader != nil) {
                    let ret = xmlTextReaderRead(reader)
                    if(ret > 0) {
                    return {{ type.targetClassName }}(reader: reader!)
                    }
                    xmlFreeTextReader(reader)
                    }
                    
                    return nil
                    }
                    
                    /**
                    * Name:            dataFrom{{ type.name }}
                    * Parameters:      A generated {{ type.targetClassName }} object
                    * Returns:         NSData from {{ type.targetClassName }} object
                    * Description:     Create the NSData object from the {{ type.targetClassName }}
                    *                  object.
                    */
                    class func dataFrom{{ type.name }}({{ type.name }}Value:{{ type.targetClassName }}) -> NSData? {
                    let buf = xmlBufferCreate()
                    if buf == nil {
                    print("Error creating the xml buffer.")
                    return nil
                    }
                    
                    let writer = xmlNewTextWriterMemory(buf, 0)
                    if writer == nil {
                    print("Error creating the xml writer.")
                    return nil
                    }
                    
                    var rc = Int(xmlTextWriterStartDocument(writer, "1.0", "utf-8", nil))
                    if rc < 0 {
                    print("Error at xmlTextWriterStartDocument.")
                    return nil
                    }
                    xmlTextWriterSetIndent(writer, 1)
                    xmlTextWriterSetIndentString(writer, "\t")
                    
                    // Serialize object
                    let {{ type.name }}Name = "{{ type.name }}"
                    let {{ type.name }}URLStr = "{{ type.schema.targetNamespace }}"
                    
                    xmlTextWriterStartElementNS(writer, nil, {{ type.name }}Name, {{ type.name }}URLStr)
                    let resultStatusCode = {{ type.name }}Value.writeWithWriter(writer: writer!)
                    
                    if resultStatusCode < 0 {
                    xmlBufferFree(buf)
                    return nil
                    }
                    
                    xmlTextWriterEndElement(writer)
                    
                    rc = Int(xmlTextWriterEndDocument(writer))
                    if rc < 0 {
                    print("Error at xmlTextWriterEndDocument.")
                    return nil
                    }
                    
                    let xmlData = NSData(bytes: buf!.pointee.content, length: Int(buf!.pointee.use))
                    //print(UnsafePointer<String>(buf.memory.content))
                    
                    xmlBufferFree(buf)
                    
                    return xmlData
                    }

                    }
                ]]>
            </class>
        </reader>
    </complextype>
    <enumeration objType="NS_ENUM" arrayType="">
        <read>
            <prefix></prefix>
            <attribute>
                <![CDATA[
                    self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}.fromString(enumString: String(cString: {{ attribute.name }}AttrValue!))
                ]]>
            </attribute>
            <element>
                <![CDATA[
                    self.{{ element.variableName }} = {{ element.schemaType.enumerationName }}.fromString(enumString: String(cString: UnsafePointer<CChar>({{ element.name }}ElementValue)))
                ]]>
            </element>
            <value>
                <![CDATA[let value = String(cString: contentValue!)
                    if value != nil {
                    let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    self.value = {{ type.enumerationName }}.fromString(enumString: trimmed)
                    }]]>
            </value>
        </read>
        <write>
            <prefix/>
            <attribute>
                <![CDATA[var {{ attribute.variableName }}AttrValue: String?
                    if self.{{ attribute.variableName }} != .Unknown {
                    {{ attribute.variableName }}AttrValue = {{ attribute.schemaType.enumerationName }}.toString(enumType: self.{{ attribute.variableName }}!)
                    }]]>
            </attribute>
            <element>
                <![CDATA[xmlTextWriterWriteElement(writer, "{{ element.name }}", {{ attribute.schemaType.enumerationName }}.toString(enumType: self.{{ element.variableName }}))]]>
            </element>
            <value>
                <![CDATA[statusCode = Int(xmlTextWriterWriteString(writer, {{ type.baseClass.enumerationName }}.toString(enumType: self.value))
                    if statusCode < 0 {
                    return statusCode
                    }]]>
            </value>
        </write>
        <implementation>
            <header extension=""></header>
            <class extension="swift">
                <![CDATA[
                    import Foundation
                    import libxml2

                    enum {{ type.enumerationName }} : {{ type.swiftIntEnum }} {
                    case Unknown = -1
                    {% for enumValue in type.enumerationValues %}case {{ type.enumerationName }}_{{ enumValue }}
                    {% /for %}
                    
                    private static let namesArray = ["Unknown"{% for enumValue in type.enumerationValues %},"{{ enumValue }}"{% /for %}]
                    
                    static func toString(enumType:{{ type.enumerationName }}) -> String! {
                    let i = enumType.rawValue + 1
                    return namesArray[i];
                    }
                    
                    static func fromString(enumString: String?) -> {{ type.enumerationName }} {
                    if var enumString = enumString {
                    let locale = Locale(identifier: "en_US_POSIX")
                    let numFormatter = NumberFormatter()
                    numFormatter.locale = (locale as Locale!)
                    
                    if(numFormatter.number(from: enumString) != nil) {
                    enumString = "Value\(enumString)"
                    }
                    if let i = namesArray.index(of: enumString) {
                    if let enumType = {{ type.enumerationName }}(rawValue:i-1) {
                    return enumType
                    }
                    }
                    }
                    return .Unknown
                    
                    }
                    }
                ]]>
            </class>
        </implementation>
    </enumeration>
</template>
